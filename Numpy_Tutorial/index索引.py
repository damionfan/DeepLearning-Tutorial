import numpy as np
import matplotlib.pyplot as plt
'''----------------------使用索引数组进行索引(输出和索引数组shape一样)------------'''
a=np.arange(12)**2
# [  0   1   4   9  16  25  36  49  64  81 100 121]
i=np.array([1,1,3,8,5])
a[i]
#[ 1  1  9 64 25]
j=np.array([[3,4],[9,7]])
a[j]
#[[ 9 16]
# [81 49]]
'''当被索引的数组a是多维的时，单个索引数组指的是第一个维度a'''
palette=np.array([
    [0,0,0],#black
    [255,0,0],#red
    [0,255,0],#green
    [0,0,255],#blue
    [255,255,255]#white
])
image = np.array([[0,1,2,0],[0,3,4,0]])
palette[image]
# [[[  0   0   0]
#   [255   0   0]
#   [  0 255   0]
#   [  0   0   0]]
#
#  [[  0   0   0]
#   [  0   0 255]
#   [255 255 255]
#   [  0   0   0]]]
'''为多个维度提供索引，每个维度的索引数组必须有相同的形状'''
a=np.arange(12).reshape(3,4)
# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]]
i=np.array([[0,1],
            [1,2]])#第一个维度的索引数组
j=np.array([[2,1],
            [3,3]])#第二个维度的索引数组
a[i,j]
# [[ 2  5]  2：a[0,2] 5:a[1,1]
#  [ 7 11]] 7:a[1,3] 11:a[2,3]
a[i,2]
# [[ 2  6]
#  [ 6 10]]
a[:,j] #a[0,j] a[1,j] a[2,j]
# [[[ 2  1]
#   [ 3  3]]
#
#  [[ 6  5]
#   [ 7  7]]
#
#  [[10  9]
#   [11 11]]]
l=[i,j]
a[l]
# [[ 2  5]
#  [ 7 11]]

'''搜索与时间相关的系列的最大值'''
time=np.linspace(20,145,5)
# [  20.     51.25   82.5   113.75  145.  ]
data=np.sin(np.arange(20)).reshape(5,4)
# [[ 0.          0.84147098  0.90929743  0.14112001]
#  [-0.7568025  -0.95892427 -0.2794155   0.6569866 ]
#  [ 0.98935825  0.41211849 -0.54402111 -0.99999021]
#  [-0.53657292  0.42016704  0.99060736  0.65028784]
#  [-0.28790332 -0.96139749 -0.75098725  0.14987721]]
ind=data.argmax(axis=0)#vertical 竖直的
# [2 0 3 1]
time_max=time[ind]
# [  82.5    20.    113.75   51.25]
'''学到了！'''
data_max=data[ind,range(data.shape[1])]#data.shape[1]=4
print(time_max)
print(data_max)
np.all(data_max==data.max(axis=0))#True
'''也可以使用索引数组用作赋值，索引数组有重复以最后一个为准
这是合理的，但请注意是否要使用Python的 +=构造，因为它可能不会按预期执行：

>>> a = np.arange(5)
>>> a[[0,0,2]]+=1
>>> a
array([1, 1, 3, 3, 4])
即使0在索引列表中出现两次，第0个元素也只增加一次。这是因为Python要求“a + = '''

'''---------------使用bool布尔类型进行索引----------------'''
'''选择那些想要，那些不想要'''
a=np.arange(12).reshape(3,4)
b=a>4
print(b)
# [[False False False False]
#  [False  True  True  True]
#  [ True  True  True  True]]
print(a[b])#[ 5  6  7  8  9 10 11]
a[b]=0
print(a)
# [[0 1 2 3]
#  [4 0 0 0]
#  [0 0 0 0]]

def mandelbrot(h,w,maxit=20):
    '''返回一个mandelbrot图像大小为(h,w)'''
    y,x=np.ogrid[-1.4:1.4:h*1j,-2:0.8:w*1j]
    c=x+y*1j
    z=c
    divtime=maxit+np.zeros(z.shape,dtype=int)
    for i in range(maxit):
        z=z**2+c
        diverge=z*np.conj(z)>2**2
        div_now=diverge&(divtime==maxit)
        divtime[div_now]=i
        z[diverge]=2

    return divtime
plt.imshow(mandelbrot(400,400))
#plt.show()
'''多个维度，类似整数索引数组'''

a=np.arange(12).reshape(3,4)
# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]]
b1=np.array([False,True,True])
b2=np.array([True,False,True,False])
a[b1,:]
# [[ 4,  5,  6,  7],
#  [ 8,  9, 10, 11]]
a[b1]
# [[ 4,  5,  6,  7],
#  [ 8,  9, 10, 11]]
a[:,b2]
# [[ 0,  2],
#  [ 4,  6],
#  [ 8, 10]]
a[b1,b2]
# [ 4, 10]

'''-------------------ix_()函数-------------------------
input:N 个1-D
output:N个，都是N-D的，但是N-1个D的shape都是1
如果要计算从每个向量a，b和c中取得的所有三元组的所有a + b * c：'''
''''''
a=np.array([2,3,4,5])
b=np.array([8,5,4])
c=np.array([5,4,6,8,3])
ax,bx,cx=np.ix_(a,b,c)
ax
# [[[2]],
#  [[3]],
#  [[4]],
#  [[5]]]
bx
# [[[8],
#   [5],
#   [4]]]
cx
# [[[5, 4, 6, 8, 3]]]
print(ax.shape,bx.shape,cx.shape)
# (4, 1, 1) (1, 3, 1) (1, 1, 5)
result=ax+bx*cx
#        [[[42, 34, 50, 66, 26],
#         [27, 22, 32, 42, 17],
#         [22, 18, 26, 34, 14]],
#        [[43, 35, 51, 67, 27],
#         [28, 23, 33, 43, 18],
#         [23, 19, 27, 35, 15]],
#        [[44, 36, 52, 68, 28],
#         [29, 24, 34, 44, 19],
#         [24, 20, 28, 36, 16]],
#        [[45, 37, 53, 69, 29],
#         [30, 25, 35, 45, 20],
#         [25, 21, 29, 37, 17]]])
result[3,2,4]
#16
a[3]+b[2]*c[4]
#17

