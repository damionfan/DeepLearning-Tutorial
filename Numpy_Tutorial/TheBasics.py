import tensorflow as tf
import numpy as np

'''-----------------------------基础知识----------------------------
在numpy中 维度成为轴 
[1,2,3] 一个轴，长度为3
[[1,2,3],
[4,5,6]] 两个轴 ，第一个轴长度为2 ，第二轴长度为3 ，轴从高纬->到低纬
数组类为ndarry 即使numpy.array也和python 的array不同，前者处理的多


ndarry.ndim :维度数/轴数,有多少个轴
ndarry.shape:(n,m) 元组 
ndarry.size : 元素总数量 =n*m
ndarry.dtype : np.int32,nnp.int16等
ndarry.itemsize : 每个元素的大小（bytes）float64: 64/8=8 ,和ndarry.dtype.itemsize相等
ndarry.data : 缓冲区 ，含有数组实际元素 一般不用
'''
a=np.arange(15).reshape(3,5)
# print(a,a.shape,a.ndim,a.dtype.name,a.itemsize,a.size,type(a))
# [[ 0  1  2  3  4]
#  [ 5  6  7  8  9]
#  [10 11 12 13 14]] (3, 5) 2 int64 8 15 <class 'numpy.ndarray'>

'''--------------------数组创建---------------------'''
a=np.array([1,2,3,4])#dtype=int64
b=np.array([1.2,2.4])#dtype=float64
'''但是使用多个数字不作为数组：
a=np.array([1,2,3]) 对
a=np.array(1,2,3) 错 '''
b=np.array([(1,3),(4,5,6)])
# print(b) [(1, 3) (4, 5, 6)]
'''可以在创建的过程中显示定义数组类型'''
c=np.array([[1,2],[3,4]],dtype=complex)
# print(c)
# [[1.+0.j 2.+0.j]
#  [3.+0.j 4.+0.j]]
'''zeros：充满0的数组，ones：充满1的数组，empty：内容随机 取决内存状态。默认dtype:int64'''
a=np.zeros((3,4))
b=np.ones((2,3,4),dtype=np.int64)
c=np.empty((2,3))
d=np.arange(10,30,5)#[10 15 20 25]
'''arange对于浮点参数（第三个步长）时，无法预测获得的元素的数量，通常用linspace'''
d=np.linspace(0,2,9)#从0到2提取9个数
# x=np.linspace(0,2*pi,100)#对于数学有用
'''-------------------打印数组----------------------
最后一个轴从左到右打印，
倒数第二个从上到下打印，
其余部分也从上到下打印，每个切片用空行分隔
如果数组太大，numpy自动跳过中心，仅打印角落，set_printoptions:强制打印整个'''
a=np.arange(6)# [0 1 2 3 4 5]
b=np.arange(12).reshape(4,3)
# [[ 0  1  2]
#  [ 3  4  5]
#  [ 6  7  8]
#  [ 9 10 11]]
c=np.arange(24).reshape(2,3,4)
# [[[ 0  1  2  3]
#   [ 4  5  6  7]
#   [ 8  9 10 11]]
#
#  [[12 13 14 15]
#   [16 17 18 19]
#   [20 21 22 23]]]
'''------------------基本操作----------------------'''
a=np.array([20,30,40,50])
b=np.arange(4)
c=a-b
# [20 29 38 47]
b**2#[0 1 4 9]
10*np.sin(a)#[ 9.12945251 -9.88031624  7.4511316  -2.62374854]
a<35#[ True  True False False]
'''  * : 元素
    dot: 数列'''

A=np.array([[1,1],
            [0,1]])
B=np.array([[2,0],
            [3,4]])
A*B
# [[2 0]
#  [0 4]]
A.dot(B) /np.dot(A,B)
# [[5 4]
#  [3 4]]
'''+= *= :修改数列，不是创建！'''
a=np.ones((2,3),dtype=int)
b=np.random.random((2,3))
'''不同精度的数组操作时，类型对应于高精度'''
b=np.arange(12).reshape(3,4)
# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]]
b.sum(axis=0)
# [12 15 18 21]
b.min(axis=1)
# [0 4 8]
b.cumsum(axis=1)#沿给定轴的元素的累积和。
# [[ 0  1  3  6]
#  [ 4  9 15 22]
#  [ 8 17 27 38]]
'''----------------通用功能-----------------
np.exp(),np.sin(),np.con(),np.sqrt(),np.add()针对元素'''

''''---------------索引，切片，迭代-------------------'''
a=np.arange(10)**3
# print(a)
# [  0   1   8  27  64 125 216 343 512 729]
a[2]# 8
a[2:5] #[ 8 27 64]
a[:6:2]=-1000
# [-1000     1 -1000    27 -1000   125   216   343   512   729]
a[::-1]
# [  729   512   343   216   125 -1000    27 -1000     1 -1000]
def f(x,y):
    return 10*x+y
b=np.fromfunction(f,(5,4),dtype=int)
# [[ 0  1  2  3]
#  [10 11 12 13]
#  [20 21 22 23]
#  [30 31 32 33]
#  [40 41 42 43]]
b[2,3] #23
b[0:5,1]#[1,11,21,31,41]
b[ : ,1]   #     [ 1, 11, 21, 31, 41]
b[1:3, : ] #     [[10, 11, 12, 13],[20, 21, 22, 23]]
b[-1]#缺失的索引认为是完整的切片 [40, 41, 42, 43]
'''可以使用b[i,...] ... 代表多个:
eg:x 5个轴 
x[1,2,...]=x[1,2,:,:,:]
x[...,3]=x[:,:,:,:,3]
x[4,...,5,:]=x[4,:,:,5,:]'''
c=np.array( [[[  0,  1,  2],               # a 3D array (two stacked 2D arrays)
            [ 10, 12, 13]],
            [[100,101,102],
            [110,112,113]]])
c.shape#(2, 2, 3)
c[1,...]
# [[100 101 102]
#  [110 112 113]]
c[...,2]
# [[  2  13]
#  [102 113]]
'''多维数组的迭代是针对第一个轴完成的'''
for row in b:
    #print(row)
    pass
    # [0 1 2 3]
    # [10 11 12 13]
    # [20 21 22 23]
    # [30 31 32 33]
    # [40 41 42 43]
'''使用flat属性可以针对所有元素'''
for element in b.flat:
    # print(element)
    pass
    # 0
    # 1
    # 2
    # 3
    # 10
    # 11
    # 12
    # 13
    # 20
    # 21
    # 22
    # 23
    # 30
    # 31
    # 32
    # 33
    # 40
    # 41
    # 42
    # 43
